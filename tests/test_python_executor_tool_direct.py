import unittest
import asyncio
from unittest.mock import patch, MagicMock, mock_open
import json
import os
import uuid

from tools.python_executor_tool import PythonExecutorTool


class TestPythonExecutorToolDirect(unittest.TestCase):
    """Direct unit tests for PythonExecutorTool functionality"""
    
    def setUp(self):
        self.mock_llm_tool = MagicMock()
        self.tool = PythonExecutorTool(llm_tool=self.mock_llm_tool)

    def test_tool_initialization(self):
        """Test that the tool initializes correctly"""
        self.assertEqual(self.tool.tool_id, "PYTHON_EXECUTOR")
        self.assertEqual(self.tool.llm_tool, self.mock_llm_tool)

    def test_create_python_code_tool_schema(self):
        """Test the tool schema creation"""
        schema = self.tool._create_python_code_tool_schema()
        
        self.assertEqual(schema["type"], "function")
        self.assertEqual(schema["function"]["name"], "generate_python_code")
        self.assertIn("python_code", schema["function"]["parameters"]["properties"])
        self.assertEqual(
            schema["function"]["parameters"]["required"], 
            ["python_code"]
        )

    def test_extract_python_code_from_tool_call_response(self):
        """Test extracting Python code from tool call response"""
        response = {
            "tool_calls": [{
                "name": "generate_python_code",
                "arguments": {
                    "python_code": "def process_step(context):\n    return context['a'] + context['b']"
                }
            }]
        }
        
        code = self.tool._extract_python_code_from_response(response)
        self.assertIn("def process_step(context)", code)
        self.assertIn("return context['a'] + context['b']", code)

    def test_extract_python_code_from_string_response(self):
        """Test extracting Python code from string response (legacy)"""
        response = "def process_step(context):\n    return context['x'] * 2"
        
        code = self.tool._extract_python_code_from_response(response)
        self.assertEqual(code, response)

    def test_extract_python_code_no_tool_calls(self):
        """Test extracting Python code when no tool calls present"""
        response = {"some_key": "some_value"}
        
        code = self.tool._extract_python_code_from_response(response)
        self.assertEqual(code, str(response))

    def test_extract_python_code_wrong_tool_call(self):
        """Test error when wrong tool call name is used"""
        response = {
            "tool_calls": [{
                "name": "wrong_tool",
                "arguments": {"python_code": "some code"}
            }]
        }
        
        with self.assertRaises(ValueError) as context:
            self.tool._extract_python_code_from_response(response)
        
        self.assertIn("Unexpected tool call: wrong_tool", str(context.exception))

    def test_extract_python_code_no_code_in_args(self):
        """Test error when no python_code in arguments"""
        response = {
            "tool_calls": [{
                "name": "generate_python_code",
                "arguments": {}
            }]
        }
        
        with self.assertRaises(ValueError) as context:
            self.tool._extract_python_code_from_response(response)
        
        self.assertIn("No Python code generated by LLM", str(context.exception))

    @patch("subprocess.run")
    @patch("uuid.uuid4")
    @patch("os.remove")
    @patch("builtins.open", new_callable=mock_open)
    @patch("os.path.exists", return_value=True)
    def test_execute_with_tool_schema_success(self, mock_exists, mock_open_func, mock_remove, mock_uuid, mock_subprocess_run):
        """Test successful execution using tool schema"""
        async def run_test():
            # Setup mocks
            mock_uuid.return_value = uuid.UUID("12345678-1234-5678-1234-567812345678")
            run_id = "12345678-1234-5678-1234-567812345678"
            
            # Mock LLM response with tool call
            async def mock_llm_execute(params):
                return {
                    "tool_calls": [{
                        "name": "generate_python_code",
                        "arguments": {
                            "python_code": "def process_step(context):\n    return {'result': context['a'] + context['b']}"
                        }
                    }]
                }
            
            self.mock_llm_tool.execute = mock_llm_execute

            # Mock subprocess
            mock_process = MagicMock()
            mock_process.stdout = "stdout message"
            mock_process.stderr = "stderr message"
            mock_subprocess_run.return_value = mock_process

            # Mock file operations
            result_data = {"return_value": {"result": 15}, "exception": None}
            mock_open_func.side_effect = [
                mock_open().return_value,  # context file write
                mock_open().return_value,  # code file write  
                mock_open(read_data=json.dumps(result_data)).return_value,  # result file read
            ]

            # Execute
            params = {
                "task_description": "Add two numbers from context",
                "related_context_content": {"a": 5, "b": 10},
            }
            result = await self.tool.execute(params)

            # Verify subprocess call
            expected_context_file = f"/tmp/context_{run_id}.json"
            expected_code_file = f"/tmp/code_{run_id}.py" 
            expected_output_file = f"/tmp/result_{run_id}.json"
            
            mock_subprocess_run.assert_called_once_with(
                [
                    "python",
                    "tools/executor_runner.py",
                    "--code-file", expected_code_file,
                    "--context-file", expected_context_file,
                    "--output-file", expected_output_file,
                ],
                capture_output=True,
                text=True,
                check=False,
            )

            # Verify result
            self.assertEqual(result["return_value"], {"result": 15})
            self.assertEqual(result["stdout"], "stdout message")
            self.assertEqual(result["stderr"], "stderr message")
            self.assertIsNone(result["exception"])
            self.assertIn("def process_step(context)", result["generated_code"])
            
            # Verify cleanup
            self.assertEqual(mock_remove.call_count, 3)

        asyncio.run(run_test())

    @patch("subprocess.run")
    @patch("uuid.uuid4")
    @patch("os.remove")
    @patch("builtins.open", new_callable=mock_open)
    @patch("os.path.exists")
    def test_execute_output_file_missing(self, mock_exists, mock_open_func, mock_remove, mock_uuid, mock_subprocess_run):
        """Test execution when output file is missing"""
        async def run_test():
            # Setup mocks
            mock_uuid.return_value = uuid.UUID("12345678-1234-5678-1234-567812345678")
            
            # Mock LLM response
            async def mock_llm_execute(params):
                return {
                    "tool_calls": [{
                        "name": "generate_python_code", 
                        "arguments": {"python_code": "def process_step(context):\n    return 'test'"}
                    }]
                }
            
            self.mock_llm_tool.execute = mock_llm_execute

            # Mock subprocess
            mock_process = MagicMock()
            mock_process.stdout = "stdout message"
            mock_process.stderr = "stderr message" 
            mock_subprocess_run.return_value = mock_process

            # Mock file operations - output file doesn't exist
            def exists_side_effect(path):
                return not path.endswith("result_12345678-1234-5678-1234-567812345678.json")
            
            mock_exists.side_effect = exists_side_effect
            mock_open_func.side_effect = [
                mock_open().return_value,  # context file write
                mock_open().return_value,  # code file write
            ]

            # Execute
            params = {
                "task_description": "Test task",
                "related_context_content": {"test": "data"},
            }
            result = await self.tool.execute(params)

            # Verify result handles missing output file
            self.assertIsNone(result["return_value"])
            self.assertEqual(result["exception"], "Output file not found.")
            self.assertEqual(result["stdout"], "stdout message")
            self.assertEqual(result["stderr"], "stderr message")

        asyncio.run(run_test())

    def test_execute_with_legacy_string_response(self):
        """Test execution with legacy string response from LLM"""
        async def run_test():
            # Mock LLM to return string instead of tool call
            async def mock_llm_execute(params):
                return "def process_step(context):\n    return 'legacy'"

            self.mock_llm_tool.execute = mock_llm_execute

            with patch("subprocess.run") as mock_subprocess_run, \
                 patch("uuid.uuid4") as mock_uuid, \
                 patch("os.remove") as mock_remove, \
                 patch("builtins.open", new_callable=mock_open) as mock_open_func, \
                 patch("os.path.exists", return_value=True) as mock_exists:

                # Setup mocks
                mock_uuid.return_value = uuid.UUID("12345678-1234-5678-1234-567812345678")
                mock_process = MagicMock()
                mock_process.stdout = "stdout"
                mock_process.stderr = "stderr"
                mock_subprocess_run.return_value = mock_process

                result_data = {"return_value": "legacy", "exception": None}
                mock_open_func.side_effect = [
                    mock_open().return_value,  # context file write
                    mock_open().return_value,  # code file write
                    mock_open(read_data=json.dumps(result_data)).return_value,  # result file read
                ]

                # Execute
                params = {
                    "task_description": "Legacy test",
                    "related_context_content": {},
                }
                result = await self.tool.execute(params)

                # Verify it still works with legacy response
                self.assertEqual(result["return_value"], "legacy")
                self.assertEqual(result["generated_code"], "def process_step(context):\n    return 'legacy'")

        asyncio.run(run_test())

if __name__ == "__main__":
    unittest.main()
